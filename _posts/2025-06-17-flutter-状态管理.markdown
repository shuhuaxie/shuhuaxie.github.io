1. 状态管理

await setupRunCommon(after: () {
    runApp(MultiProvider(
      providers: [
        ChangeNotifierProvider.value(
          value: userProvider,
        ),
        ChangeNotifierProvider.value(
          value: noticeNewOrderProvider,
        ),
      ],
      child: POSApp(homePage: homePage?.call(), homeRoute: homeRoute),
    ));
  });
  
  - 
  future stream
  
  微任务 + 宏任务 + 渲染
  宏任务 在限定时间 或者任务执行结束后
  进入渲染任务
  future delay 0 可以将普通任务切分成多个任务，任务放到队列的尾部，可能跨帧执行
 
  事件循环中有 时间和io监听机制，支持网络请求和定时任务
   网络请求的回调等也是宏任务
 
 -   
   Isolate 通过‌内存隔离+消息传递‌实现并发
   
每个 Isolate 拥有‌独立的事件循环‌ (Event Loop)，包含 MicroTask 和 Event 队列47；
通过 Isolate.spawn() 创建，开销介于线程和进程之间
   
  scheduleFrameCallback
  addPostFrameCallback
Isolate 之间可以直接通讯，而不同的engine之间不能直接通讯，为什么？


- 语言级内存隔离 ｜ 操作系统级进程隔离

- 消息传递 ｜ 夸进程 序列化/反序列化

- 
状态管理
- InheritedWidget
    context.dependOnInheritedWidgetOfExactType()
    上下文 (Context) 的作用‌：BuildContext 本质上是当前 Widget 对应的 ‌Element‌。当调用 dependOnInheritedWidgetOfExactType() 23 时：
‌       向上查找‌：它会沿着 Element 树向上查找，直到找到最近的、类型匹配的 InheritedElement（即步骤 1 中创建的）。
‌       注册依赖‌：一旦找到目标 InheritedElement，它会将这个‌调用者 Widget 所对应的 Element‌ 添加到 InheritedElement 内部的 ‌依赖者列表 (_dependents)‌ 中。这相当于建立了一个 "订阅" 关系：调用者 Element 声明它依赖于这个 InheritedElement。
‌       返回共享数据‌：该方法最终返回找到的 InheritedWidget 实例，从而让调用者 Widget 可以访问其存储的数据。

数据存储与挂载
依赖关系的建立
    -- 子组件获取数据 dependOnInheritedWidgetOfExactType
    -- 向上查找匹配的第一个InheritedElement
    -- 注册依赖
    -- 获取数据
数据变更与更新传播
    -- InheritedWidget 重建
    -- 数据发生变化
    -- 通知监听者列表
    -- didChangeDependencies 标记为dirty
    -- 依赖者重建
- Provider‌

child: Consumer<UserProvider>(builder: (context, state, child) {
            return _ownerText(context);
          }))

- 
三棵树

- 
生命周期

web3dart_builders
code builder - class builder
 
 shoppingcart/all  floorselections
 
 https://pos-api-staging-02.chowbus.com/api/v2/floor/sections
 https://pos-api-staging-02.chowbus.com/api/v3/order/overviews
 didChangeDependencies








    






