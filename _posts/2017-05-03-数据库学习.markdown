---
layout: post
title:  "数据库学习"
date:   2017-05-03 16:51:30 +0800

---
* 本地连接到数据库

C:\Program Files\MySQL\MySQL Server 5.7\bin>mysql -u root -p
Enter password: **** <br>

* 创建数据库

create database xiexie

* 查询数据库版本

select Version();

* 显示时间

SELECT *,FROM_UNIXTIME(createTime/1000, '%Y-%m-%d %H:%i:%s') 

* 查询注意

SELECT * FROM ibd_cm.task_job where jobCode = "201705150944-1" 如果把双引号去掉会查不出来

* 执行计划 explain +任意sql语句

explain SELECT * FROM ibd_cm.task_job where jobCode = "201705150944-1"
<br>

* 数据库时间

SELECT
    LEFT(FROM_UNIXTIME(UNIX_TIMESTAMP('2017-06-26 00：00：00')),
        10) date,
    (UNIX_TIMESTAMP('2017-06-26 00：00：00')),
    (UNIX_TIMESTAMP('2017-06-26')),
    FROM_UNIXTIME('1498406400');

* 数据库函数
SELECT
    CONCAT(id, '-', jobCode) '工单Id+工单号',
    if(planFinishTime >= finishTime, '正常', if(left(planFinishTime, 7) = left(finishTime, 7), '新增延迟', '历史延迟'))    '交付状态',
    if (0>1,0,1) 'test'
FROM
    task_job;

* 数据库命令
    show table status;  -- 显示当前库所有表的状态
    show processlist;   -- 显示连接数
    select * from information_schema.processlist  where db = 'ibd_cm';

* 索引
where语句的=后面值需要和存储类型保持一致(字符串或者数字),否则索引会无效.

* 日期函数
DATE_ADD('2017-07-27 10:00:00', INTERVAL - 600 MINUTE)

* 下载文件
sz -e ibd_cm_20170818_1736.sql.gz

* 组内数据合并

select id, group_concat(mainFieldName) from gather_product_info where jobId = 342749810820006912 group by hbaseId;
267623	良品,不良,工序进度,废品
267630	废品,工序进度,不良,良品
267640	废品,工序进度,不良,良品
267641	良品,工序进度
267643	良品,工序进度

* mysql运行测试

1)A join B 和 B join A 运行先后顺序是否相同  : 
    顺序不同,一般情况下业务场景两种方式不能转换
2)Between 是否使用索引 :  
    对于range类型，选择性小于17%了，就会走全表扫描，而非range。
    MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及xx%的LIKE。
3)A join B 会不会在联结的时候使用B的索引,如果联结项有多个,如何合理使用索引
    对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。
